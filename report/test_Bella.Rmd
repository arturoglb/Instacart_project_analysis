### one more eda try to find more interest

```{r}

# Weighted average of orders for each department to see how each department is doing

productsales <- user_purchases %>%
  select(department, product_name) %>%
  group_by(department, product_name) %>%
  summarise(ordercount = n()) %>%
  group_by(department)%>%
  summarise(meansales = weighted.mean(ordercount)) %>%
  ggplot(aes(x=department, y=meansales))+
  geom_col()

productreorder <- user_purchases %>%
  select(department, product_name, reordered) %>%
  group_by(department, reordered) %>%
  summarise(ordercount = n()) %>%
  ggplot(aes(x=department,
         y=ordercount,
         fill=reordered))+
  geom_col(position = "stack")


productsales
productreorder



```

```{r}
#play data
user_purchases <- orders %>%
  filter(eval_set == "train") %>%
  left_join(order_products_train, by = "order_id") %>%
  left_join(products, by = "product_id") %>%
  left_join(aisles, by = c("aisle_id")) %>%
  left_join(departments, by = c("department_id"))

allorder <- user_purchases %>%
  group_by(order_id, department) %>%
  summarise(product_num = n()) %>%
  pivot_wider(names_from = "department", values_from = "product_num") %>%
  left_join(user_purchases, by = "order_id") %>%
  relocate(order_dow, .before = `canned goods`) %>%
  relocate(order_hour_of_day, .before = `canned goods`) %>%
  relocate(days_since_prior_order, .before = `canned goods`)%>%
  select(-reordered, -user_id, -eval_set, -order_number, -product_id, -product_name, -add_to_cart_order, -aisle, -aisle_id, -department, -department_id, -beverages) 

library(fastDummies)

beverage_reorder <- user_purchases %>%
  filter(department == "beverages") %>%
  select(order_id, department, reordered) %>%
  mutate(Reordered =ifelse(
  reordered == 1, "Yes", "No")) %>% 
  dummy_cols(remove_first_dummy = F) %>%
  select(order_id, Reordered_Yes) 

allorder <- allorder %>%
  left_join(beverage_reorder, by="order_id")

allorder[is.na(allorder)] <- 0

allorder <- allorder%>%
  mutate(reorderbeverage =ifelse(
  Reordered_Yes == 1, "Yes", "No")) %>%
  select(-Reordered_Yes) #here, reordered_yes/no indicate if the order has reordered beverage 

allorder[,2:4] <- lapply(allorder[,2:4], as.factor)  
allorder$reorderbeverage <- as.factor(allorder$reorderbeverage)

colnames(allorder) <- make.names(colnames(allorder))

# sampling
set.seed(12345) # for reproducibility
index.tr <- createDataPartition(y = allorder$order_id, p= 0.01,list = FALSE)
df.tr <- allorder[index.tr,]
df.te <- allorder[-index.tr,]

#unbalanced
table(df.tr$reorderbeverage)

n.yes <- min(table(df.tr$reorderbeverage)) 
df.tr.no <- filter(df.tr, reorderbeverage=="No") ## the "No" cases
df.tr.yes <- filter(df.tr, reorderbeverage=="Yes") ## The "Yes" cases
index.no <- sample(size=n.yes, x=1:nrow(df.tr.no), replace=FALSE) 
df.tr.subs <- data.frame(rbind(df.tr.yes, df.tr.no[index.no,])) 
table(df.tr.subs$reorderbeverage) ## The cases are balanced


#model
set.seed(12345)
model_tree <- caret::train(reorderbeverage ~ .,
                           data = df.tr.subs[,-1],
                           method ="rpart",
                           preProcess = NULL,
                           trControl=trainControl(method="repeatedcv", number=10,
                                                  repeats=10, verboseIter=FALSE,
                                                  sampling="down"))

# Plot the Tree

rpart.plot(model_tree$finalModel, cex = 0.6 )

# Another way to plot
par(mar = c(0.5, 1, 0.5, 1))
plot(model_tree$finalModel, branch = 1)
text(model_tree$finalModel, digits = 1, use.n = TRUE, cex = 0.6, pretty=1)

# Apply Model to the test dataset

set.seed(12345)
model_tree_pred <- predict(model_tree, newdata=df.te)
table(Pred= model_tree_pred, Obs=df.te$reorderbeverage)

# Measure the accuracy of the prediction

confusionMatrix(data=as.factor(model_tree_pred), reference = df.te$reorderbeverage)

```

