## EDA

```{r, echo = FALSE, message = FALSE, warning=FALSE}
source(here::here("scripts/setup.R"))
```

### **Data Description**

**`orders`** (3.4m rows, 206k users):\
\* `order_id`: order identifier\
\* `user_id`: customer identifier\
\* `eval_set`: which evaluation set this order belongs in (see `SET`
described below)\
\* `order_number`: the order sequence number for this user (1 = first, n
= nth)\
\* `order_dow`: the day of the week the order was placed on\
\* `order_hour_of_day`: the hour of the day the order was placed on\
\* `days_since_prior`: days since the last order, capped at 30 (with NAs
for `order_number` = 1)

**`products`** (50k rows):\
\* `product_id`: product identifier\
\* `product_name`: name of the product\
\* `aisle_id`: foreign key\
\* `department_id`: foreign key

**`aisles`** (134 rows):\
\* `aisle_id`: aisle identifier\
\* `aisle`: the name of the aisle

**`departments`** (21 rows):\
\* `department_id`: department identifier\
\* `department`: the name of the department

**`order_products__SET`** (30m+ rows):\
\* `order_id`: foreign key\
\* `product_id`: foreign key\
\* `add_to_cart_order`: order in which each product was added to cart\
\* `reordered`: 1 if this product has been ordered by this user in the
past, 0 otherwise

where **`SET`** is one of the four following evaluation sets (`eval_set`
in `orders`):\
\* `"prior"`: orders prior to that users most recent order (\~3.2m
orders)\
\* `"train"`: training data supplied to participants (\~131k orders)\
\* `"test"`: test data reserved for machine learning competitions (\~75k
orders)\
<br>

#### **Table 1 - aisles**

```{r echo=FALSE, message=FALSE}
aisles <- read.csv(here::here("data/aisles.csv"), header = TRUE)

#missing value
sum(is.na(aisles)) #0

kable(aisles[,], caption = "The aisles table") %>%
  kable_styling(bootstrap_options = "bordered") %>%
  kableExtra::scroll_box(width = "100%", height = "250px")
```

#### **Table 2 - departments**

```{r echo=FALSE, message=FALSE}
departments <- read.csv(here::here("data/departments.csv"), header = TRUE)

#missing value
sum(is.na(departments)) #0

kable(departments[,], caption = "The departments table") %>%
  kable_styling(bootstrap_options = "bordered") %>%
  kableExtra::scroll_box(width = "100%", height = "250px")
```

#### **Table 3 - products**

```{r echo=FALSE, message=FALSE}
products <- read.csv(here::here("data/products.csv"), header = TRUE)

#missing value
sum(is.na(products)) #0

kable(products[1:50,], caption = "The products table") %>%
  kable_styling(bootstrap_options = "bordered") %>%
  kableExtra::scroll_box(width = "100%", height = "250px")
```

#### **Table 4 - order_products_train**

```{r echo=FALSE, message=FALSE}
order_products_train <- read.csv(here::here("data/order_products__train.csv"), header = TRUE)

#missing value
sum(is.na(order_products_train)) #0

kable(order_products_train[1:50,], caption = "The order_products_train table") %>%
  kable_styling(bootstrap_options = "bordered") %>%
  kableExtra::scroll_box(width = "100%", height = "250px")
```

#### **Table 5 - order**

```{r, fig.height=6, fig.width=10}
orders <- read.csv(here::here("data/orders.csv"), header = TRUE)

#missing value
sum(is.na(orders)) #206209
max(orders$user_id) #206209
#meaning that data is complete

orders %>% filter(eval_set == "train" ) %>%
  select(-order_id, -user_id, -order_number) %>%
  inspect_num() %>%
  show_plot(col_palette = 3)
```

We can observe on the first chart `days_since_prior_order` that most of
the users have a higher probability to do another purchase order after a
week from the previous purchase. Also, we can visualize on the graph
`oder_dow` that the most frequent days of ordering are Sunday's and
Monday's comparing to the rest of the week, and on the last chart
`order_hour_of_day`,we note a high demand of orders between 9am to 6pm.

#### **Table 6 - user_purchases**

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Identify the products purchased with their departments and the time and day of consumption
user_purchases <- orders %>%
  filter(eval_set == "train") %>%
  left_join(order_products_train, by = "order_id") %>%
  left_join(products, by = "product_id") %>%
  left_join(aisles, by = c("aisle_id")) %>%
  left_join(departments, by = c("department_id")) %>%
  select(-eval_set, -add_to_cart_order, -product_name, -aisle, -department)
```

### **Data preparation for Analysis** 

```{r echo=FALSE, message=FALSE}

############## Data with 2 Levels Yes and No - Reordered -  ###################

# sample from distinct values of user_id
train_users <- user_purchases %>% 
  select(user_id, order_id) %>%
  distinct %>%
  slice_head(n= 50000)

# merge the two datasets
users_1k <-
  left_join(train_users, user_purchases)
  

data <- users_1k %>% mutate(Reordered =ifelse(
  reordered == 1, "Yes", "No")) %>%
  select(-reordered)

# Transform y variable to a factor
data$Reordered<- as.factor(data$Reordered)


# Make Valid Column Names 
colnames(data) <- make.names(colnames(data))

# Separate our data into Training set and Test set
set.seed(12345) # for reproducibility
index.tr <- createDataPartition(y = data$Reordered, p= 0.8,list = FALSE)
df.tr <- data[index.tr,]
df.te <- data[-index.tr,]

# Building a Classification tree model: Considering a Repeated Cross-Validation with a Class balancing of sub-sampling
set.seed(12345)
model_tree <- caret::train(Reordered ~ .,
                           data = df.tr,
                           method ="rpart",
                           preProcess = NULL,
                           trControl=trainControl(method="repeatedcv", number=10,
                                                  repeats=10, verboseIter=FALSE,
                                                  sampling="down"))

# Plot the Tree

rpart.plot(model_tree$finalModel, cex = 0.6 )

# Another way to plot
par(mar = c(0.5, 1, 0.5, 1))
plot(model_tree$finalModel, branch = 1)
text(model_tree$finalModel, digits = 1, use.n = TRUE, cex = 0.6, pretty=1)

# Apply Model to the test dataset

set.seed(12345)
model_tree_pred <- predict(model_tree, newdata=df.te)
table(Pred= model_tree_pred, Obs=df.te$Reordered)

# Measure the accuracy of the prediction

confusionMatrix(data=as.factor(model_tree_pred), reference = df.te$Reordered)
```
